
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSS 滤镜 filter / backdrop-filter：模糊、透明图阴影、调色、毛玻璃、渐进式模糊效果</title>
    <link rel="shortcut icon" href="code.svg" type="image/x-icon" />
    <link rel="stylesheet" href="../skill/css/article.css">
    <link rel="stylesheet" href="../skill/css/prism.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;500&display=swap">
</head>
<body class="line-numbers">
    <nav class="nav-bar">
        <a href="index.html" class="nav-home">首页</a>
    </nav>
    <article class="article-container">
        <!-- 左侧目录 -->
        <aside class="article-toc">
            <div class="toc-header">
                <div class="toc-title">
                    <i class="fas fa-list"></i>
                    <span>文章目录</span>
                </div>
            </div>
            <div class="toc-content"></div>
        </aside>

        <!-- 中间文章主体 -->
        <main class="article-main">
            <header class="article-header">
                <h1>CSS 滤镜 filter / backdrop-filter：模糊、透明图阴影、调色、毛玻璃、渐进式模糊效果</h1>
                <div class="article-meta">
                    
                    <time datetime="Tue Mar 11 2025 05:28:06 GMT+0800 (中国标准时间)">
                        <i class="far fa-calendar-alt"></i>
                        2025年3月11日
                    </time>
                    
                    <div class="article-tags">
                        <span class="tag"><i class="fas fa-tag"></i>filter / backdrop-filter</span>
                    </div>
                    
                </div>
            </header>
            <div class="article-content">
                <h2>一. 滤镜 filter</h2>
<p><code>filter</code>属性能让你对 HTML 元素本身做一系列的图像处理效果，让我们能在不使用绘图软体的情况下实现各种特效，例如：模糊、明度、对比度等。</p>
<pre><code class="language-css">div {
  filter: 方法(数值);
}
</code></pre>
<h3>特效效果</h3>
<p>而<code>filter</code>总共有以下几种效果可以使用：</p>
<img src="./images/20.png" />

<blockquote>
<p>演示： <a href="https://codepen.io/im1010ioio/pen/YzmPbMr">CSS 过滤器</a></p>
</blockquote>
<ul>
<li><code>blur</code><strong>：模糊</strong><br>需要填写数值，单位可以是<code>px</code> 、 <code>em</code> 、 <code>rem</code>等。</li>
<li><code>brightness</code><strong>：明度</strong><br>调整亮度，需要填写百分比值：100%为原本的明度，往下是调暗，往上是调亮。</li>
<li><code>contrast</code>: 对比度<br>调整对比度，需要填写百分比值：100%为原本的对比度，往下是减低，往上是增加。</li>
<li><code>grayscale</code> ：灰阶<br>转为灰阶，需要填写 0 到 1 之间的值，1 代表完全灰阶。</li>
<li><code>hue-rotate</code> <strong>：色相</strong><br>调整色相环的位置，需要填写角度，单位可以是<code>deg</code> （度数）或<code>turn</code> （圈数）。</li>
<li><code>invert</code> ：反转<br>转为相反的颜色，会变成对比色，需要填写 0 到 1 之间的值，1 代表完全相反。</li>
<li><code>opacity</code><strong>：透明度</strong><br>调整对比度，需要填写百分比值：100%为不透明，效果等同于： <code>opacity: 數值;</code> 。</li>
<li><code>sepia</code><strong>：棕褐色</strong><br>转为怀旧的褐色调，需要填写 0 到 1 之间的值，1 代表完全褐色。</li>
<li><code>saturate</code> ：饱和度<br>调整饱和度，需要填写百分比值：100%为原本的对比度，往下是减低，往上是增加。</li>
<li><code>drop-shadow</code> <strong>：阴影</strong><br>在图片中非透明的周围加上阴影，这针对透明图片超好用！例如，如果单单为透明图片加上基本的阴影<code>box-shadow</code> ，会像下方图片一样悲剧，阴影没有加在实际图案的周围，但用了<code>filter</code>的<code>drop-shadow</code>就能为实际图案的边缘加上阴影：</li>
</ul>
<img src="./images/21.png" />

<blockquote>
<p>演示： <a href="https://codepen.io/im1010ioio/pen/XWvbbWG">CSS box-shadow 与 filter drop-shadow</a></p>
</blockquote>
<h3>多重特效</h3>
<p>你也可以使用多种特效在一个 HTML 元素上，只要简单使用空格隔开就好了，例如：</p>
<pre><code class="language-css">div {
  filter: contrast(175%) brightness(105%);
}
</code></pre>
<h2>二. 背景滤镜<code>backdrop-filter</code></h2>
<p><code>backdrop-filter</code>可以对 HTML 元素后面的背景制作滤镜效果，影响的是背后的东西，而不是自己本身。最常见的是用来制作非常受欢迎的「<strong>毛玻璃效果 Glassmorphism</strong> 」，利用模糊区隔出背景，制造出透明感的景深效果，最常见被用在 iOS 系统中、弹跳视窗光箱（lightbox）或是导览列（Navbar）上等等。</p>
<p>在 Dribbble 上搜寻的 Glassmorphism 的话，会出现以下像这样酷炫的 UI，给大家参考：</p>
<img src="./images/22.png" />

<h3>基本语法</h3>
<p><code>backdrop-filter</code>语法的使用方式，基本上和<code>filter</code>一样：</p>
<pre><code class="language-css">div {
  backdrop-filter: 方法(数值);
}
</code></pre>
<h3>特效效果</h3>
<p><code>backdrop-filter</code>通常用在浮动的 HTML 元素上（如：绝对定位、固定定位、 <code>sticky</code>等等）。它可使用的效果和<code>filter</code>一样，请参考上面<code>filter</code>所列出来的所有效果。</p>
<p>只不过经我实测， <code>opacity</code>和<code>drop-shadow</code>不起作用，所以以下的 DEMO 范例没有它们：</p>
<img src="./images/23.png" />

<blockquote>
<p>演示： <a href="https://codepen.io/im1010ioio/pen/RwXNzOd">CSS 背景滤镜</a></p>
</blockquote>
<p>刚刚说的「毛玻璃效果 Glassmorphism」就是使用其中的<code>blur()</code>效果。</p>
<h3>多重特效</h3>
<p>和<code>filter</code>一样，你也可以使用多种特效在一个 HTML 元素上，只要简单使用空格隔开就好了，例如：</p>
<pre><code class="language-css">.element {
  backdrop-filter: blur(10px) brightness(60%);
}
</code></pre>
<p>上面的例子会将元素后面的背景模糊处理，并且使其稍微变暗（亮度调低至 60%）。这样可以做出类似黑色毛玻璃效果。</p>
<h2>三、渐进式模糊（Progressive blur）</h2>
<p>会用<code>backdrop-filter</code>后，搭配昨天我们学到的 CSS <code>mask</code>语法，我们还可以进一步制作渐进式模糊。</p>
<blockquote>
<p>延伸阅读： <a href="https://im1010ioio.hashnode.dev/css-mask">#45 CSS 中的半透明遮罩 mask，实现各种模糊边缘特效</a></p>
</blockquote>
<p>什么是渐进式模糊呢？渐进式模糊（Progressive blur）就是 UI 中照片下半部会逐渐模糊，然后下方显示其他文字资讯等。</p>
<img src="./images/24.png" />

<p>这种背景模糊的 UI，在 Apple 的 iOS UI 中很常出现这种效果（例如： <a href="https://www.apple.com/tw/newsroom/2025/02/introducing-apple-invites-a-new-app-that-brings-people-together/">Apple Invites</a> ），过去在网页上很难做到，但是现在只要灵活运用这两个语法就能做到啰！</p>
<h3>演示</h3>
<p>这边我们在有背景图的<code>div</code>上，新增一个满版的伪元素<code>::before</code>并且设定背景滤镜<code>backdrop-filter</code> ，然后再透过 CSS <code>mask</code>线性渐层调整模糊的范围，就可以做到啦！</p>
<img src="./images/25.png" />

<pre><code class="language-scss">.photo {
  position: relative;
  overflow: hidden;
  background-image: url(&quot;image.jpg&quot;);
  background-size: cover;
  overflow: hidden;
  &amp;::before {
    content: &quot;&quot;;
    display: block;
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    backdrop-filter: blur(10px);
    mask: linear-gradient(180deg, transparent 350px, #000 450px);
  }
}
</code></pre>
<blockquote>
<p>DEMO 连接： <a href="https://codepen.io/im1010ioio/pen/raBXezV">CSS 渐进式模糊</a></p>
</blockquote>
<h2>四、固定定位（<code>fixed</code>）+ <code>filter</code>/<code>backdrop-filter</code> 的陷阱</h2>
<p>如果 fixed 项目的父层上有<code>filter</code>或<code>backdrop-filter</code>属性，该 fixed 项目就不会依据「浏览器的视窗大小」进行定位，而是依据「该 HTML 的父层」定位。</p>
<p>做个实例给大家参考看看：</p>
<blockquote>
<p><a href="https://codepen.io/im1010ioio/pen/VwoLvey">固定项目与过滤器（背景过滤器）之间的冲突</a></p>
</blockquote>
<p><strong>解法：</strong> 改变 filter 的元素，或是改使用 sticky 做到类似效果。</p>
<blockquote>
<p>延伸阅读：</p>
<ul>
<li><a href="https://im1010ioio.hashnode.dev/css-position">#21 CSS Position：相对、绝对、固定、粘性定位 适合的定位</a></li>
<li><a href="https://juejin.cn/post/6844904117974859783">filter 与 fixed 冲突的原因及解决方案 - 掘金</a></li>
</ul>
</blockquote>

            </div>
            <div class="article-footer">
                <div class="article-share">
                    <span>分享文章：</span>
                    <a href="javascript:void(0)" class="share-btn" data-platform="twitter"><i class="fab fa-twitter"></i></a>
                    <a href="javascript:void(0)" class="share-btn" data-platform="facebook"><i class="fab fa-facebook"></i></a>
                    <a href="javascript:void(0)" class="share-btn" data-platform="linkedin"><i class="fab fa-linkedin"></i></a>
                </div>
                <div class="article-actions">
                    <button class="action-btn" id="backToTop"><i class="fas fa-arrow-up"></i> 返回顶部</button>
                </div>
            </div>
        </main>

        <!-- 右侧相关文章 - 简化版 -->
        
        
        <!-- 移动端目录切换按钮 -->
        <button class="toc-toggle" aria-label="切换目录">
            <i class="fas fa-chevron-right"></i>
        </button>
    </article>
    <script src="../skill/js/prism.js"></script>
    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // 目录切换功能
        const toc = document.querySelector('.article-toc');
        const tocToggle = document.querySelector('.toc-toggle');
        
        // 从 localStorage 获取目录状态
        const tocCollapsed = localStorage.getItem('tocCollapsed') === 'true';
        
        // 初始化目录状态
        if (tocCollapsed) {
            toc.classList.add('collapsed');
        }
        
        // 切换按钮点击事件
        tocToggle.addEventListener('click', () => {
            toc.classList.toggle('collapsed');
            localStorage.setItem('tocCollapsed', toc.classList.contains('collapsed'));
        });
        
        // 生成目录
        const content = document.querySelector('.article-content');
        const tocContent = document.querySelector('.toc-content');
        const headings = content.querySelectorAll('h2, h3');
        
        if (headings.length > 0) {
            const tocList = document.createElement('ul');
            
            headings.forEach((heading, index) => {
                // 添加锚点ID
                const id = `heading-${index}`;
                heading.id = id;
                
                // 创建目录项
                const li = document.createElement('li');
                li.className = `toc-${heading.tagName.toLowerCase()}`;
                
                const link = document.createElement('a');
                link.href = `#${id}`;
                link.textContent = heading.textContent;
                
                li.appendChild(link);
                tocList.appendChild(li);
                
                // 添加锚点链接到标题
                const anchor = document.createElement('a');
                anchor.className = 'heading-anchor';
                anchor.href = `#${id}`;
                anchor.innerHTML = '<i class="fas fa-link"></i>';
                anchor.title = '复制链接';
                
                // 点击锚点复制链接
                anchor.addEventListener('click', (e) => {
                    e.preventDefault();
                    const url = window.location.href.split('#')[0] + '#' + id;
                    navigator.clipboard.writeText(url).then(() => {
                        const tooltip = document.createElement('div');
                        tooltip.className = 'copy-tooltip';
                        tooltip.textContent = '链接已复制';
                        document.body.appendChild(tooltip);
                        
                        setTimeout(() => {
                            tooltip.classList.add('show');
                        }, 10);
                        
                        setTimeout(() => {
                            tooltip.classList.remove('show');
                            setTimeout(() => {
                                document.body.removeChild(tooltip);
                            }, 300);
                        }, 2000);
                    });
                });
                
                heading.appendChild(anchor);
                
                // 点击目录项时在移动端收起目录
                link.addEventListener('click', (e) => {
                    if (window.innerWidth <= 1280) {
                        toc.classList.add('collapsed');
                        localStorage.setItem('tocCollapsed', 'true');
                    }
                });
            });
            
            tocContent.appendChild(tocList);
        }
        
        // 目录滚动高亮
        const observerOptions = {
            root: null,
            rootMargin: '-100px 0px -66%',
            threshold: [0, 1]
        };
        
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                const id = entry.target.id;
                const tocItem = document.querySelector(`.toc-content a[href="#${id}"]`);
                
                if (entry.isIntersecting) {
                    // 移除其他项的高亮
                    document.querySelectorAll('.toc-content a').forEach(item => {
                        item.classList.remove('active');
                    });
                    // 添加当前项的高亮
                    tocItem?.classList.add('active');
                    
                    // 将当前项滚动到可视区域
                    if (tocItem) {
                        const tocContent = document.querySelector('.toc-content');
                        const itemTop = tocItem.offsetTop;
                        const contentHeight = tocContent.clientHeight;
                        const scrollTop = tocContent.scrollTop;
                        
                        if (itemTop < scrollTop || itemTop > scrollTop + contentHeight) {
                            tocContent.scrollTo({
                                top: itemTop - contentHeight / 2,
                                behavior: 'smooth'
                            });
                        }
                    }
                }
            });
        }, observerOptions);
        
        headings.forEach(heading => observer.observe(heading));
        
        // 代码块复制功能
        const codeBlocks = document.querySelectorAll('pre');
        codeBlocks.forEach((block, index) => {
            const container = block.parentNode;
            if (container.className === 'code-block') {
                const language = block.querySelector('code').className.match(/language-([a-z]+)/)?.[1] || 'code';
                container.setAttribute('data-language', language);
                
                const copyBtn = document.createElement('button');
                copyBtn.className = 'copy-button';
                copyBtn.innerHTML = '<i class="far fa-copy"></i>';
                copyBtn.title = '复制代码';
                
                copyBtn.addEventListener('click', () => {
                    const code = block.textContent;
                    navigator.clipboard.writeText(code).then(() => {
                        copyBtn.innerHTML = '<i class="fas fa-check"></i>';
                        copyBtn.classList.add('copied');
                        
                        setTimeout(() => {
                            copyBtn.innerHTML = '<i class="far fa-copy"></i>';
                            copyBtn.classList.remove('copied');
                        }, 2000);
                    });
                });
                
                container.appendChild(copyBtn);
            }
        });
        
        // 返回顶部按钮
        const backToTopBtn = document.getElementById('backToTop');
        backToTopBtn.addEventListener('click', () => {
            window.scrollTo({
                top: 0,
                behavior: 'smooth'
            });
        });
        
        // 分享按钮
        const shareButtons = document.querySelectorAll('.share-btn');
        shareButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                const platform = btn.getAttribute('data-platform');
                const url = encodeURIComponent(window.location.href);
                const title = encodeURIComponent(document.title);
                
                let shareUrl = '';
                switch (platform) {
                    case 'twitter':
                        shareUrl = `https://twitter.com/intent/tweet?url=${url}&text=${title}`;
                        break;
                    case 'facebook':
                        shareUrl = `https://www.facebook.com/sharer/sharer.php?u=${url}`;
                        break;
                    case 'linkedin':
                        shareUrl = `https://www.linkedin.com/sharing/share-offsite/?url=${url}`;
                        break;
                }
                
                if (shareUrl) {
                    window.open(shareUrl, '_blank', 'width=600,height=400');
                }
            });
        });
        
        // 图片点击放大
        const images = document.querySelectorAll('.article-content img');
        images.forEach(img => {
            img.addEventListener('click', () => {
                const overlay = document.createElement('div');
                overlay.className = 'image-overlay';
                
                const imgClone = document.createElement('img');
                imgClone.src = img.src;
                imgClone.alt = img.alt;
                
                overlay.appendChild(imgClone);
                document.body.appendChild(overlay);
                
                setTimeout(() => {
                    overlay.classList.add('show');
                }, 10);
                
                overlay.addEventListener('click', () => {
                    overlay.classList.remove('show');
                    setTimeout(() => {
                        document.body.removeChild(overlay);
                    }, 300);
                });
            });
        });
    });
    </script>
</body>
</html>
